import * as XLSX from "xlsx-js-style";

export function stox(wb) {
    var out = [];
    wb.SheetNames.forEach(function (name) {
        var o = { name: name, rows: {} };
        var ws = wb.Sheets[name];
        if (!ws || !ws["!ref"]) return;
        var range = XLSX.utils.decode_range(ws["!ref"]);
        range.s = { r: 0, c: 0 };
        var aoa = XLSX.utils.sheet_to_json(ws, { raw: false, header: 1, range: range });
        aoa.forEach(function (r, i) {
            var cells = {};
            r.forEach(function (c, j) {
                cells[j] = { text: c || String(c) };
                var cellRef = XLSX.utils.encode_cell({ r: i, c: j });
                if (ws[cellRef] != null && ws[cellRef].f != null) {
                    cells[j].text = "=" + ws[cellRef].f;
                }
            });
            o.rows[i] = { cells: cells };
        });
        o.rows.len = aoa.length;
        o.merges = [];
        (ws["!merges"] || []).forEach(function (merge, i) {
            if (o.rows[merge.s.r] == null) {
                o.rows[merge.s.r] = { cells: {} };
            }
            if (o.rows[merge.s.r].cells[merge.s.c] == null) {
                o.rows[merge.s.r].cells[merge.s.c] = {};
            }
            o.rows[merge.s.r].cells[merge.s.c].merge = [merge.e.r - merge.s.r, merge.e.c - merge.s.c];
            o.merges[i] = XLSX.utils.encode_range(merge);
        });
        out.push(o);
    });
    return out;
}

/*  11/04/2025
    Source: https://github.com/myliang/x-spreadsheet/issues/419 
*/

export function xtos(sdata, keepMerges = true, keepFormulas = true) {
  function transformStyle(styleObj) {
    const result = {};
    if (styleObj)
      Object.keys(styleObj).map(key => {
        switch (key) {
          case 'align':
            result['alignment'] = Object.assign(result['alignment'] || {}, { horizontal: styleObj[key] });
            break;
          case 'valign':
            result['alignment'] = Object.assign(result['alignment'] || {}, { vertical: styleObj[key] });
            break;
          case 'font':
            result['font'] = Object.assign(result['font'] || {}, styleObj[key]);
            if (result['font'] && result['font']['size'])
              result['font'] = Object.assign(result['font'] || {}, { sz: styleObj[key]['size'] });
            break;
          case 'underline':
            result['font'] = Object.assign(result['font'] || {}, { underline: styleObj[key] });
            break;
          case 'strike':
            result['font'] = Object.assign(result['font'] || {}, { strike: styleObj[key] });
            break;
          case 'color':
            result['font'] = Object.assign(result['font'] || {}, { color: { rgb: styleObj[key].slice(1) } });
            break;
          case 'bgcolor':
            // result["fill"] = Object.assign((result["fill"] || {}), { bgColor: { rgb: styleObj[key].slice(1) },patternType:"solid" });
            result['fill'] = Object.assign(result['fill'] || {}, { fgColor: { rgb: styleObj[key].slice(1) }, patternType: 'solid' });
            break;
          case 'border':
            result['border'] = Object.assign(result['border'] || {}, {
              top: styleObj[key]['top'] ? { style: styleObj[key]['top'][0], color: { rgb: styleObj[key]['top'][1].slice(1) } } : null,
              bottom: styleObj[key]['bottom']
                ? { style: styleObj[key]['bottom'][0], color: { rgb: styleObj[key]['bottom'][1].slice(1) } }
                : null,
              left: styleObj[key]['left'] ? { style: styleObj[key]['left'][0], color: { rgb: styleObj[key]['left'][1].slice(1) } } : null,
              right: styleObj[key]['right']
                ? { style: styleObj[key]['right'][0], color: { rgb: styleObj[key]['right'][1].slice(1) } }
                : null
            });
            break;
          case 'textwrap':
            result['alignment'] = Object.assign(result['alignment'] || {}, { wrapText: styleObj[key] });
            break;
          default:;
        }
      });
    return result;
  }
  function formatText(styleObj) {
    let format = '';
    if (styleObj)
      Object.keys(styleObj).map(key => {
        if ('format' === key) {
          switch (styleObj[key]) {
            case 'scientific':
              format = '0.00E+0';
              break;
            case 'percent':
              format = '0.00%';
              break;
            case 'number':
              format = '0.00';
              break;
            default:
          }
        }          
      });
    return format;
  }
  const out = XLSX.utils.book_new();
  sdata.forEach((xws)=> {
    const ws = {};
    const rowobj = xws.rows;
    let minCoord = { r: 0, c: 0 },
      maxCoord = { r: 0, c: 0 };
    for (let ri = 0; ri < rowobj.len; ++ri) {
      const row = rowobj[ri];
      if (!row) continue;

      Object.keys(row.cells).forEach((k)=> {
        const idx = +k;
        if (isNaN(idx)) return;

        const lastRef = XLSX.utils.encode_cell({ r: ri, c: idx });
        if (minCoord === undefined) {
          minCoord = { r: ri, c: idx };
        } else {
          if (ri < minCoord.r) minCoord.r = ri;
          if (idx < minCoord.c) minCoord.c = idx;
        }
        if (maxCoord === undefined) {
          maxCoord = { r: ri, c: idx };
        } else {
          if (ri > maxCoord.r) maxCoord.r = ri;
          if (idx > maxCoord.c) maxCoord.c = idx;
        }

        let cellText = row.cells[k].text,
          type = 's';
        if (!cellText) {
          cellText = '';
          // keep style and format
          const styleIndex = row.cells[k].style
          if(undefined === styleIndex || null === styleIndex){
            type = 'z';  // type 'z' will not export style
          }
          if(undefined !== styleIndex && xws.styles[styleIndex]['format'] && 'scientific' === xws.styles[styleIndex]['format']){
            cellText = 0;
            type = 'n'; 
          }
        } else if (!isNaN(parseFloat(cellText))) {
          cellText = parseFloat(cellText);
          type = 'n';
        } else if (cellText === 'true' || cellText === 'false') {
          cellText = Boolean(cellText);
          type = 'b';
        }
        ws[lastRef] = {
          v: cellText,
          t: type,
          z: formatText(xws.styles[row.cells[k].style]),
          s: transformStyle(xws.styles[row.cells[k].style])
        };
       
        if (keepFormulas && type === 's' && cellText[0] === '=') {
          ws[lastRef].f = cellText.slice(1);
        }

        if (keepMerges && row.cells[k].merge !== undefined) {
          if (ws['!merges'] === undefined) ws['!merges'] = [];

          ws['!merges'].push({
            s: {
              r: ri,
              c: idx
            },
            e: {
              r: ri + row.cells[k].merge[0],
              c: idx + row.cells[k].merge[1]
            }
          });
        }
      });
      ws['!ref'] =
        XLSX.utils.encode_cell({ r: minCoord.r, c: minCoord.c }) + ':' + XLSX.utils.encode_cell({ r: maxCoord.r, c: maxCoord.c });
    }
    XLSX.utils.book_append_sheet(out, ws, xws.name);
  });
  return out;
}

export function exportSheet(sheet, filename) {
    /* build workbook from the grid data */
    var new_wb = xtos(sheet.getData());
    console.log(new_wb);
}
